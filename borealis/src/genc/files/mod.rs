//! Intermediate representation of GenC files
//!
//! This means we can do two things:
//!
//! * Maintain a clear, understandable user-facing structure for a GenC
//!   description (`crate::genc::Description`)
//! * Use `std::fmt::Display` and recursion to generate each file (a nice
//!   pattern), without requiring globals or external state

use std::fmt::{self, Display, Formatter};

mod behaviours;
mod execute;
mod isa;
mod main;

pub use crate::genc::files::{
    behaviours::Behaviours,
    execute::Execute,
    isa::{Format, Isa},
    main::Main,
};

/// GenC files which may be rendered using only the `std::fmt::Display` trait,
/// achieved by duplicating several pieces of information between structs.
///
/// Only for internal use; users of library should use
/// `crate::genc::Description` which does not contain duplicated information.
#[derive(Debug, Clone)]
pub struct Files {
    pub main: Main,
    pub isa: Isa,
    pub execute: Execute,
    pub behaviours: Behaviours,
}

#[derive(Debug, Clone)]
pub enum Function {
    Behaviour {
        name: String,
        body: String,
        global: bool,
    },
    Execute {
        name: String,
        body: String,
    },
    Helper {
        return_type: String,
        parameters: String,
        name: String,
        body: String,
    },
}

impl Display for Function {
    fn fmt(&self, f: &mut Formatter) -> fmt::Result {
        match self {
            Function::Behaviour { name, body, global } => {
                writeln!(
                    f,
                    "behaviour({name}) {}{{",
                    if *global { "global " } else { "" }
                )?;
                writeln!(f, "{body}")?;
                writeln!(f, "}}")
            }
            Function::Execute { name, body } => {
                writeln!(f, "execute({name}) {{")?;
                writeln!(f, "{body}")?;
                writeln!(f, "}}")
            }
            Function::Helper {
                return_type,
                parameters,
                name,
                body,
            } => {
                writeln!(f, "internal helper {return_type} {name}({parameters}) {{")?;
                writeln!(f, "{body}")?;
                writeln!(f, "}}")
            }
        }
    }
}

/// Creates a file and writes the initial comment
fn write_header(f: &mut Formatter) -> fmt::Result {
    writeln!(f, "/* GENERATED BY BOREALIS */\n\n")
}
