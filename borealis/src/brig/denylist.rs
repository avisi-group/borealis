use sailrs::{
    jib_ast::{self, Definition, Instruction, InstructionAux, Type, Value, Vl},
    sail_ast::Location,
    types::ListVec,
};

pub fn apply_fn_denylist<I: Iterator<Item = jib_ast::Definition>>(
    iter: I,
) -> impl Iterator<Item = jib_ast::Definition> {
    iter.map(|def| {
        if let Definition::Fundef(name, idk, arguments, body) = def {
            let body = if !DENYLIST.contains(&name.as_interned().as_ref()) {
                body
            } else {
                ListVec::from(vec![Instruction {
                    inner: InstructionAux::Throw(Value::Lit(Vl::Unit, Type::Unit)),
                    annot: (0, Location::Unknown),
                }])
            };

            Definition::Fundef(name, idk, arguments, body)
        } else {
            def
        }
    })
}

const DENYLIST: &[&'static str] = &[
    "neq_bool",
    "_shl_int_general",
    "_shr_int_general",
    "fmod_int",
    "ThrowSError",
    "ReservedEncoding",
    "__UNKNOWN_integer",
    "__UNKNOWN_bit",
    "EncodingSpecificOperations",
    "LSL_C",
    "LSR_C",
    "ASR_C",
    "ROR_C",
    "asl_Int",
    "Elem_read",
    "write_gpr_bits",
    "set_R_bits",
    "GetTimestamp",
    "ELIsInHost",
    "IsInHost",
    "BranchRawCycleCount",
    "FirstBranchAfterProhibited",
    "FilterBranchRecord",
    "CurrentInstrSet",
    "BadMode",
    "RBankSelect",
    "LookUpRIndex",
    "Rmode_read",
    "R_read",
    "PC_read__1",
    "FloorPow2",
    "CeilPow2",
    "IsPow2",
    "ImplementedSVEVectorLength",
    "CurrentNSVL_read",
    "ImplementedSMEVectorLength",
    "RestoreTransactionCheckpointParameterised",
    "RestoreTransactionCheckpoint",
    "FailTransaction",
    "FailTransaction__1",
    "Halt",
    "Halt__1",
    "CheckForPMUOverflow",
    "Split",
    "RShr",
    "NonSecureOnlyImplementation",
    "DBGOSLSR_read",
    "ICInstNeedsTranslation",
    "DCInstNeedsTranslation",
    "DecodeSW",
    "BitReverse",
    "Poly32Mod2",
    "ROL",
    "AESShiftRows",
    "AESInvShiftRows",
    "AESSubBytes",
    "AESInvSubBytes",
    "FFmul02",
    "FFmul03",
    "FFmul09",
    "FFmul0B",
    "FFmul0D",
    "FFmul0E",
    "RecipEstimate",
    "UnsignedRecipEstimate",
    "RecipSqrtEstimate",
    "UnsignedRSqrtEstimate",
    "SignedSatQ",
    "UnsignedSatQ",
    "SatQ",
    "AdvSIMDExpandImm",
    "PolynomialMult",
    "MatMulAdd",
    "ExcVectorBase",
    "EncodeSDFSC",
    "ExtAbortToA64",
    "FPInfinity",
    "FPMaxNormal",
    "FPEXC_read",
    "FPEXC_write",
    "FPSCR_write",
    "FPProcessException",
    "FPZero",
    "FPRoundBase__1",
    "FPDecodeRounding",
    "FPRoundingMode",
    "FPRound",
    "FPRound__1",
    "FPRound__2",
    "FixedToFP",
    "FPUnpackBase",
    "FPUnpackBase__1",
    "FPUnpack",
    "FPUnpack__1",
    "FPAbs",
    "FPDefaultNaN",
    "FPDefaultNaN__1",
    "FPProcessDenorms",
    "FPProcessNaN",
    "FPProcessNaN__1",
    "FPProcessNaNs",
    "FPProcessNaNs__1",
    "FPAdd",
    "FPAdd__1",
    "FPAdd_ZA",
    "FPCompare",
    "FPCompareEQ",
    "FPCompareGE",
    "FPCompareGT",
    "FPConvertNaN",
    "FPProcessDenorm",
    "FPRoundCV",
    "FPUnpackCV",
    "FPConvert",
    "FPConvert__1",
    "FPDecodeRM",
    "FPDiv",
    "FPMax",
    "FPMax__1",
    "FPMaxNum",
    "IsMerging",
    "FPMin",
    "FPMin__1",
    "FPMinNum",
    "FPMul",
    "FPProcessDenorms3",
    "FPProcessNaNs3__1",
    "FPMulAdd",
    "FPMulAdd__1",
    "FPMulAdd_ZA",
    "FPTwo",
    "FPMulX",
    "FPProcessNaNs3H",
    "FPMulAddH",
    "FPMulAddH__1",
    "FPMulAddH_ZA",
    "FPNeg",
    "FPOnePointFive",
    "FPRecipEstimate",
    "FPRecpX",
    "FPRoundInt",
    "FPRoundIntN",
    "FPRSqrtEstimate",
    "FPSqrt",
    "FPSub",
    "FPSub__1",
    "FPSub_ZA",
    "FPThree",
    "FPToFixed",
    "FPToFixedJS",
    "VFPExpandImm",
    "IsTimerConditionMet",
    "SetEventRegister",
    "TestEventCNTP",
    "TestEventCNTV",
    "GenericCounterTick",
    "PAREncodeShareability",
    "EncodePARAttrs",
    "DecodeShareability",
    "S2CombineS1Shareability",
    "EffectiveShareability",
    "DecodeDevice",
    "S2CombineS1Device",
    "DecodeSDFAttr",
    "DecodeLDFAttr",
    "S2DecodeCacheability",
    "S2CombineS1AttrHints",
    "FPCompareUN",
    "FPCompareNE",
    "FPOne",
    "FPPointFive",
    "GetOptimizedScale",
    "FPScale",
    "Reverse",
    "FPTrigSMul",
    "FPTrigSSel",
    "FPTrigMAddCoefficient_read",
    "FPTrigMAdd",
    "FPExpCoefficient_read",
    "FPExpA",
    "PredTest",
    "DecodePredCount",
    "Reduce",
    "Reduce__1",
    "ReducePredicated",
    "FPConvertSVE",
    "FPConvertSVE__1",
    "IsEven",
    "ShiftSat",
    "BitDeposit",
    "BitExtract",
    "BitGroup",
    "FPLogB",
    "GCSSS1",
    "GCSSS2",
    "GCSPUSHM",
    "GCSPOPM",
    "GCSPUSHX",
    "GCSPOPCX",
    "GCSPOPX",
    "CPYOptionA",
    "CPYFOptionA",
    "SETOptionA",
    "SETGOptionA",
    "MaxBlockSizeCopiedBytes",
    "BFRound",
    "BFUnpack",
    "BFMulH",
    "FPAdd_BF16",
    "BFMulAddH",
    "BFMulAddH_ZA",
    "FPRoundBF",
    "FPConvertBF",
    "FPConvertBF__1",
    "FPProcessNaNs4",
    "FPDot__1",
    "BFDotAdd",
    "BFMatMulAdd",
    "BFNeg",
    "BFNeg__1",
    "BFInfinity",
    "BFZero",
    "BFAdd",
    "BFAdd__1",
    "BFAdd_ZA",
    "BFSub",
    "BFSub__1",
    "BFSub_ZA",
    "BFMulAdd",
    "BFMulAdd__1",
    "BFMulAdd_ZA",
    "BFMul",
    "BFMul__1",
    "BFMin",
    "BFMin__1",
    "BFMinNum",
    "BFMax",
    "BFMax__1",
    "BFMaxNum",
    "FPMatMulAdd",
    "FPDotAdd",
    "FPDotAdd_ZA",
    "EffectiveMDSELR_EL1_BANK",
    "SPESampleAddAddressPCVirtual",
    "CollectContextIDR1",
    "CollectContextIDR2",
    "CollectTimeStamp",
    "RRX_C",
    "Shift_C",
    "A32ExpandImm_C",
    "A32ExpandImm",
    "DecodeImmShift",
    "DecodeRegShift",
    "Shift",
    "T32ExpandImm_C",
    "T32ExpandImm",
    "HSTR_read",
    "D_read",
    "FPHalvedSub",
    "StandardFPSCRValue",
    "FPRecipStep",
    "FPRSqrtStep",
    "UnsignedSat",
    "SignedSat",
    "Sat",
    "genRandomNum",
    "getCacheID",
    "CacheConfigRead",
    "GetNreg",
    "UnallocatedA32_Instruction",
    "UnallocatedT32_32_Instruction",
    "UnallocatedT32_16_Instruction",
    "__DefaultCond",
    "ExecuteA64", // remove me next
    "ExecuteA32",
    "ExecuteT32__1",
    "ExecuteT16",
    "__FetchInstr",
    "__TryDecodeExecute",
    "__DecodeExecute",
    "__CheckForEmulatorTermination",
    "__InstructionExecute",
    "__TopLevel",
    "__CycleEnd",
    "AccessDescriptor_to_Access_kind",
    "sail_mem_read",
    "read_request",
    "sail_mem_write",
    "write_request",
    "take_exception",
    "gic_readonly",
    "__ReadUART",
    "__WriteUART",
    "IsPhysicalSErrorPending",
    "ClearPendingPhysicalSError",
    "__UpdateSystemCounter",
    "SetInterruptRequestLevel",
    "DataMemoryBarrier",
    "DataSynchronizationBarrier",
    "InstructionSynchronizationBarrier",
    "SpeculationBarrier",
    "SupportedPowerTwoSVL",
    "PhysMemTagWrite",
    "PhysMemTagRead",
    "__EndCycle",
    "__ListConfig",
    "__Reset",
    "ActionRequired",
    "AddressSupportsLS64",
    "DiscardTransactionalWrites",
    "EnterLowPowerState",
    "ErrorIsContained",
    "ErrorIsSynchronized",
    "FaultIsCorrected",
    "GPTTLBCache",
    "GPTTLBLookup",
    "GetAccumulatedFPExceptions",
    "GetCacheInfo",
    "GetLoadStoreType",
    "GetPendingPhysicalSError",
    "IsASEInstruction",
    "IsExternalAbortTakenSynchronously",
    "IsSynchronizablePhysicalSErrorPending",
    "LS64InstructionSyndrome",
    "LocalTimeoutEvent",
    "MarkExclusiveGlobal",
    "MarkExclusiveLocal",
    "PendSErrorInterrupt",
    "ProfilingSynchronizationBarrier",
    "RemapRegsHaveResetValues",
    "step_model",
    "main",
];
